<!DOCTYPE html>
<html lang="ja">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>暗号資産とは何か</title>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
        <link rel="stylesheet" href="../../共通/stylesheet_contents.css">
        <link rel="stylesheet" href="../../共通/stylesheet_footer.css">
        <script src="../../共通/mathjax-config.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </head>
    <body>
        <header>
            <h2>暗号資産とは何か</h2>
        </header>
        <div class="subtitle">
            貨幣の民主化
        </div>
        <div class="toc-container">
            <div class="part">
                <h3 class="part-title">目次</h3>
                <a href="#section-public">公開鍵暗号方式</a>
                <a href="#section-server-p2p">サーバー・P2P</a>
                <a href="#section-ledger-chain">分散型台帳・ブロックチェーン</a>
                <a href="#section-crypto">暗号資産</a>
            </div>
        </div>
        <main>
            <section id="section-public">
                <h4>公開鍵暗号方式</h4>
                <p>
                    　インターネットの利用者が爆発的に増加した現代において、"インターネット" という単語は極めて抽象的な概念に昇華されているものの、それが有する機能は大別すれば2つしかない。
                    1つ目は利用者が他の利用者に情報を送信する機能であり、2つ目は利用者が他の利用者から情報を送信された場合にそれを受信する機能である。
                    技術的な話題をさておけば、情報を送信したからといってそれが受信される保証はないが、受信するためには情報が送信されている必要がある。
                    したがってインターネットにおいては基本的に送信が受信に先行し、その後適切に受信が行われることで、はじめて情報の送受信が成り立つ。
                </p>
                <p>
                    　インターネットによって情報を受信するとき、送信者を信頼できるか判定するための、古典的であるが現代でも通用する巧妙な暗号理論の手法がある。
                    バリエーションは無数にあるものの、概して以下の手順を<span class="new-word">公開鍵暗号方式（public-key encryption algorithms）</span>と呼ぶ。
                    まず任意のインターネット利用者 \(\textrm{X}\) は、ある時点で信頼できると判断した任意の利用者 \(\textrm{Y}\) に対して、一方に<span class="new-word">秘密鍵（secret key）</span>、もう一方に<span class="new-word">公開鍵（public key）</span>と名前をつけた \(\textrm{Y}\) 固有の相異なる文字列 \( \textrm{sk}_\textrm{Y} \)、\( \textrm{pk}_\textrm{Y} \) を送信しておく。
                    次に \(\textrm{X}\) は任意の文字列 \( m \) と任意の秘密鍵 \( \textrm{sk}_\textrm{Y} \) に対して文字列を返す2変数関数 \( \textrm{sign}(m,\textrm{sk}_\textrm{Y}) \) であって、引数から関数値を容易に求められるが、関数値から引数を推定することが困難なものを任意の利用者に公開しておく。
                    関数値 \( \textrm{sign}(m,\textrm{sk}_\textrm{Y}) \) を \( (m,\textrm{sk}_\textrm{Y}) \) の<span class="new-word">デジタル署名（digital signature）</span>と呼ぶ。
                    同時に \(\textrm{X}\) は任意の文字列 \( m \) 、任意の公開鍵 \( \textrm{pk}_\textrm{Y} \) 、任意の文字列 \( \sigma \) 対する3変数関数 \( \textrm{verify}(m,\textrm{pk}_\textrm{Y};\sigma) \) であって
                </p>
                <div class="math-container">
                    \[
                        \textrm{verify}(m,\textrm{pk}_\textrm{Y};\sigma)=
                        \begin{cases}
                            1 &(\sigma=\textrm{sign}(m,\textrm{sk}_\textrm{Y}))\\
                            0 &(\sigma\neq\textrm{sign}(m,\textrm{sk}_\textrm{Y}))\\
                        \end{cases}
                    \]
                </div>
                <p>
                    を満たすものを用意しておく。
                    そして \(\textrm{X}\) は任意の利用者 \(\textrm{Y}\) に対して、任意の文字列 \( m \) を送信するときは、自身の公開鍵 \( \textrm{pk}_\textrm{Y} \) とデジタル署名 \( \sigma:=\textrm{sign}(m,\textrm{sk}_\textrm{Y}) \) を添えなければそれを信頼しない旨を伝えておく。
                    以上の手順を準備しておけば、\(\textrm{X}\) は \(\textrm{Y}\) から受信したと断定できない情報 \( (m,\textrm{pk}_\textrm{Y};\sigma) \) に対して \( \textrm{verify}(m,\textrm{pk}_\textrm{Y};\sigma) \) を計算し、結果が \( 1 \) になれば送信者を確かに \( \textrm{Y} \) であると信頼すればよい。
                </p>
                <p>
                    　公開鍵暗号方式について、基本的な事項で何点か補足が必要である。
                    1点目として、公開鍵暗号方式は情報の送信者を特定の者と信頼できるか判定する手法であり、情報の信憑性は一切保証しない。
                    送信者を特定の者と信頼できても、彼が悪意を持っているかは分からず、情報そのものはいくらでも不確かで危険なものになり得る。
                    2点目として、利用者は秘密鍵と公開鍵を他者に公開することが禁止されていない。
                    したがって公開することは自由であるが、その場合彼はなりすましの被害を受ける可能性があるため、合理的な者は誰も公開しないだけである。
                    3点目として、\( \textrm{sign} \) と \( \textrm{verify} \) は実際に機能する関数が数多く知られており、現実世界で幅広く用いられている（RSA、ECDSA、Schnorr署名等）。
                    言うまでもなく、\( \textrm{sign} \) と \( \textrm{verify} \) の順問題は容易であるほど \( \textrm{sign} \) の逆問題は難解であるほど実用性が高い。
                </p>
            </section>
            <section id="section-server-p2p">
                <h4>サーバー・P2P</h4>
                <p>
                    　一部の者たちが蓄積した膨大な情報を他の者たちが利活用することは、現代におけるインターネットの典型的な使い方である。
                    一般に、一部の公的機関や企業（または稀に個人）であって標準的な個人よりも膨大な情報を蓄積する者あるいはそのための装置を<span class="new-word">サーバー（server）</span>と呼ぶ。
                    インターネットの利用者はサーバーに対して、任意の文字列 \( m \) を蓄積するよう " \( m \) を蓄積せよ" という文字列形式の情報を送信できる。
                    サーバーはそのような情報をつねに受信し、公開鍵暗号方式で送信者を信頼できると判定すれば、 \( m \) を自動で蓄積するよう設計されている。
                    もし送信者を信頼できるか確認する手順がなければ、なりすましによって悪意のある情報がいくらでも蓄積されてしまう。
                    またインターネットの利用者はサーバーに対して、蓄積された情報 \( m^\prime \) を彼あるいは特定の者 \( \textrm{X} \) に宛てて送信するよう " \( \textrm{X} \) へ \( m^\prime \) を送信せよ"  という文字列形式の情報を送信できる。
                    サーバーはそのような信号をつねに受信し、公開鍵暗号方式で送信者を信頼できると判定すれば、\( \textrm{X} \) へ \( m^\prime \) を自動で送信するよう設計されている。
                    もし送信者を信頼できるか確認する手順がなければ、なりすましによって悪意のある情報が \( \textrm{X} \) へ送信されてしまう。
                    もはや死語であろうが、いわゆる "ネットサーフィン" はサーバーから情報を受信する行為である。
                    またいずれ死語になるであろうが、いわゆる "SNS" はサーバーを介して利用者たちが情報を送受信する行為である。
                </p>
                <p>
                    　インターネットが情報を送受信するための便利な技術に留まらず、情報化社会という新たな世相を構築していくにあたり、サーバーによる情報の局在化と送受信の中央集権化は相補的な指導原理であり続けた。
                    2000年代頃以降にスマートフォンが世界中で爆発的に普及したことで、安全で安定した情報の蓄積と送受信を可能にするサーバーの重要性は飛躍的に上昇した。
                    歴史を振り返れば、そこに商機を見出したのは主に米国の新興企業たちである。
                    彼らは単に情報を蓄積して要求された情報を送信するサーバー群を開発するだけでなく、膨大な情報から効率的に指定の情報を発見する仕掛けを実装したり、インターネット上に広告を掲載する新たなマーケティングの舞台を整えたりした。
                    インターネット利用者がその圧倒的に便利なサーバー群を利用するにつれて、情報の局在化と送受信の中央集権化は加速的に進んでいった。                    
                </p>
                <p>
                    　情報とその送受信に限った話ではないが、中央集権化には利点と欠点が存在する。
                    もっとも重要な利点の1つは、中央が全体を管理できることである。
                    そして同時にもっとも重大な欠点の1つは、中央が全体を管理できなくなる可能性があることである。
                    またもし中央が高度な管理を実現し一時的に万事を上手く回しても、その管理がどれだけ完全に近く持続的であるかという問題に対して中央は解を持ち得ない。
                </p>
                <p>
                    　中央集権化が過度に進んだ場合、そのアンチテーゼとして権力や管理の分散が提唱されることは世の常である。
                    インターネットでも何らかの中央集権化が進むたび、分散を図るような方法が自然発生的に提唱されてきた。
                    その土台すなわちインターネットの利用者たちが互いに対等な条件で情報を送受信するための技術を<span class="new-word">P2P（peer-to-peer）</span>と呼ぶ。
                    利用者の一方に送受信に係る条件が課されているとき、もう一方にも同様の条件が課されていればそれはP2Pである。
                    サーバーとその利用者の間の送受信は明らかに非対称でありP2Pではない。
                    P2Pは1970年代頃に確立された古典的な技術であるが、公開鍵暗号方式と同様に汎用性が高く多様な場面で応用される。
                    重要なことは、どのような中央集権化に対してP2Pと公開鍵暗号方式でどのように権力や管理の分散を図るかである。
                </p>
            </section>
            <section id="section-ledger-chain">
                <h4>分散型台帳・ブロックチェーン</h4>
                <p>
                    　貨幣の取引において、その結果を貨幣の受渡でなく記録によって管理することは、はるか昔から日常的に行われてきた。
                    記録を<span class="new-word">台帳（ledger）</span>、その更新を<span class="new-word">記帳（record）</span>と呼ぶ。
                    簡単のため1種類の貨幣のみを考えるならば、記帳すべき情報は "いつ・誰が・誰へ・いくら渡す" で十分である。
                    （受渡で受けと渡しは不可分であるから、上記は "いつ・誰が・誰から・いくら受取る" でも議論は同様である。）
                    例えば商人がノートに1行ずつ貨幣の取引を記帳していけば、都度貨幣を受渡すことなく商売を行える。
                    適当なタイミングで台帳を見直し、受けと渡しを必要に応じて相殺して差額のみを実際に受渡すことで、最小限の手間で必要なだけの貨幣を取引できる。
                </p>
                <p>
                    　インターネットの登場により、サーバーが台帳を管理するという発想が生まれた。
                    任意の利用者 \( \textrm{X} \) は任意の利用者 \( \textrm{Y} \) へ支払が発生するたびサーバーへ "いつ・\( \textrm{X} \) が・\( \textrm{Y} \) へ・いくら渡す" という文字列形式の情報をデジタル署名とともに送信すればよい。
                    サーバーは公開鍵暗号方式で送信者を信頼できると判定すれば台帳を更新し、それをもって \( \textrm{X} \) の記帳が完了する。
                    支払をする者が記帳するよう定めておけば、望んで貨幣を失う非合理な者がいない限り台帳は信頼できるものになる。
                    ただしサーバーは一切の悪意を持たず台帳を改竄しないはずであり、サーバーは十分高度であって台帳は悪意ある者から改竄を受けないはずであるという条件が暗に仮定されている。
                </p>
                <p>
                    　インターネットで台帳を管理するならば、改竄が起こり得るサーバーに頼りきらず、任意の利用者たちがP2Pと公開鍵暗号方式で台帳を管理する方法も1つの選択肢になり得る。
                    さしあたり、ある利用者 \( \textrm{A} \) が他の利用者から情報を受信して台帳を更新することにし、彼は台帳を改竄しないものと仮定する。
                    上記と同様に、任意の利用者 \( \textrm{X} \) は任意の利用者 \( \textrm{Y} \) へ支払が発生するたび \( \textrm{A} \) へ \( m:= \) "いつ・\( \textrm{X} \) が・\( \textrm{Y} \) へ・いくら渡す" という文字列形式の情報をデジタル署名 \( \sigma:=\textrm{sign}(m,\textrm{sk}_\textrm{X}) \) とともに送信する。
                    やはり \( \textrm{A} \) は公開鍵暗号方式で送信者を信頼できると判定すれば台帳を更新し、それをもって \( \textrm{X} \) の記帳が完了する。
                    ここで \( \textrm{A} \) のみが台帳のすべてを閲覧できれば記帳はP2Pではなくなるので、台帳は利用者全員に公開される必要がある。
                    また記帳の信憑性を担保するために各 \( m \) は対応するデジタル署名 \( \sigma \) とともに公開される必要がある。
                    このとき、悪意ある者が台帳を改竄する可能性が生じる。
                    言うまでもなく公開鍵暗号方式によって \( \textrm{A} \) 以外の者が架空の記帳を行えないことは担保されている。
                    しかし例えば \( \textrm{Y} \) に悪意がある場合、公開されている \( m \) に同じく公開されている \( \sigma \) を添えて \( \textrm{A} \) へ送信すれば、それは支払をすべき \( \textrm{X} \) による記帳ではないにも関わらず台帳に記帳されてしまう。
                    これを回避するには、\( \textrm{X} \) が記帳するとき \( m \) の文頭に固有の整数 \( k \in \textbf{Z}_{\geq1} \) を添えて \( m_k:= \) " \( k \_ m \) " とすればよい。
                    （ここで " \( \_ \) " は文をつなぐための便宜的な装飾にすぎない。）
                    具体的には台帳における \( k \) 番目（行目）の記帳では \( k \) を添えれば十分である。
                    すると公開されるのは \( m_k \) と \( \sigma_k:=\textrm{sign}(m_k,\textrm{sk}_\textrm{X}) \) であり、もし悪意ある者が \( m_l \) 、\( l\neq k \) を記帳しようとしても、彼は \( \textrm{sk}_\textrm{X} \) を知らず \( \sigma_l:=\textrm{sign}(m_l,\textrm{sk}_\textrm{X}) \) を生成できないので台帳を改竄できない。
                    上記の仕組みにおいて、台帳が \( \textrm{A} \) 以外の悪意ある者から改竄を受ける見込みは、サーバーが台帳を死守するときのそれよりも十分に低くなる。
                    しかし言うまでもなく、\( \textrm{A} \) は任意の利用者に秘密鍵を送信することで公開鍵暗号方式の環境を構築しており、彼はその秘密鍵でいくらでも台帳を改竄できる状態である。
                    そこで \( \textrm{A} \) が悪意を持って台帳を改竄することをどのように回避するかが、原理的に堅牢な台帳を構成するために重要な課題となる。
                </p>
                <p>
                    　特定の1人が台帳を管理すると彼への依存は不可避であるから、素朴には任意の利用者が台帳を管理すればよい。
                    すなわち、任意の利用者は各々で台帳を用意し自身の支払を他の利用者に記帳してもらうとともに、他の利用者から情報を受信して自身の台帳を更新していき、それをつねに公開しておく。
                    このように運営される台帳を<span class="new-word">分散型台帳（distributed ledger）</span>と呼ぶ。
                    そして以下の手順によって改竄されていないことを最も信頼できる台帳を決め、それを真の台帳として扱う。
                    まず任意の文字列に対して \( \{ 1,2,3,...,2^N \} \) 、\( N \in \textbf{Z}_{\geq1} \) の元を返す関数 \( \textrm{hash} \) であって、引数から関数値を容易に求められるが、関数値から引数を推定することが困難なものを任意の利用者で共有しておく。
                    次に台帳への記帳が \( L \in \textbf{Z}_{\geq1} \) 回（行）だけ行われたとき、希望する利用者は台帳を1つの文字列 \( \textrm{ledger} \) とみなしその文末に任意の文字列 \( m \) を追加して \( \textrm{ledger} \_ m \) とし \( \textrm{hash} \) に入力する。
                    （ここで " \( \_ \) " は文をつなぐための便宜的な装飾にすぎない。）
                    このような希望者を<span class="new-word">マイナー（miner）</span>と呼ぶ。
                    任意の利用者にはあらかじめある \( T \leq N \) が共有されており、マイナーたちはある文字列 \( m \) で \( \textrm{hash}(\textrm{ledger} \_ m) &lt; T \) なるものを無作為に探す。
                    このような総当たりの計算を<span class="new-word">マイニング（mining）</span>と呼ぶ。
                    明らかに \( m \) は一意でないが、ともかく一定の時間をかけてマイナーたちの内で最初に \( m \) を見つけた者はそれを \( \textrm{ledger} \) とともに公開する。
                    任意の利用者は \( \textrm{ledger} \) を閲覧し、 \( \textrm{hash}(\textrm{ledger} \_ m) &lt; T \) であること、また自身の記帳があれば改竄されていないことを確かめる。
                    この確認が終わったとき、\( m \) を \( \textrm{ledger} \) に対する<span class="new-word">PoW（proof of work）</span>、\( T \) をその<span class="new-word">ターゲット（target）</span>と呼ぶ。
                    続けて記帳をする場合は新たな台帳を用意し、その冒頭（ \( 0 \) 行目）に上記のPoWを記帳しておき、やはり \( L \) 回（行）だけ記帳を行い、PoWを見つける。
                    もしこのような手続きを繰り返した場合、最初の台帳とそのPoWの組 \( ( \textrm{ledger}_1, \textrm{PoW}_1 ) \) および \( n \in \textbf{Z}_{\geq1} \) 番目の台帳のPoW、\( n+1 \) 番目の台帳、そのPoWの組 \( ( \textrm{PoW}_n, \textrm{ledger}_{n+1}, \textrm{PoW}_{n+1} ) \) は "1本の鎖" として
                </p>
                <div class="math-container">
                    \[
                        ( \textrm{ledger}_1, \textrm{PoW}_1 ) \overset{\textrm{mining}}{\rightarrow} ( \textrm{PoW}_1, \textrm{ledger}_2, \textrm{PoW}_2 ) \overset{\textrm{mining}}{\rightarrow} \cdots \overset{\textrm{mining}}{\rightarrow} ( \textrm{PoW}_n, \textrm{ledger}_{n+1}, \textrm{PoW}_{n+1} ) \overset{\textrm{mining}}{\rightarrow} \cdots
                    \]
                </div>
                <p>
                    を生成する。
                    各組 \( ( \textrm{PoW}_n, \textrm{ledger}_{n+1}, \textrm{PoW}_{n+1} ) \) を<span class="new-word">ブロック（block）</span>、全体を<span class="new-word">ブロックチェーン（blockchain）</span>と呼ぶ。
                    ここで \( \textrm{PoW}_{n+1} \) は \( \textrm{PoW}_n \) と \( \textrm{ledger}_n \) に対するPoWであるから、もし悪意ある者が \( n \) 番目のブロックを改竄するためには、\( n \) 番目以降のすべてのPoWを1人でマイニングしなければならない。
                    しかも他のマイナーの隙を窺って最新の台帳分までPoWを見つければよいだけでなく、それ以後の台帳に対するPoWを1人で他のマイナーよりも早く見つけ続けなければならない。
                    この意味でブロックチェーンはいくらでも改竄され得るものであるが、更新され続けている最長のブロックチェーンはもっとも信憑性が高い。
                </p>
                <!--
                <p>
                    　あるインターネットの利用者が情報を公開しているとして、彼がそれを編集したか否かを確かめることは容易である。
                    すなわち、ある時刻で公開されている情報を控えておき任意の時刻に突合して差異がなければ、彼は情報を編集していないとは判断できる。
                    
                </p>
                -->
            </section>

            <section id="section-portfolio">
                <h4>ポートフォリオの定義</h4>
                <p>
                    あ
                </p>
                <div class="comment-box">
                    <p>
                        <span class="comment-box-title">ロールダウン効果の実在性</span>
                    </p>
                    <p>
                        債券といえば、クーポンやデュレーションが議論の対象になることが多い。
                        クーポンは債券に明記され、デュレーションは定義式から計算されるため、これらの "存在" を疑う者はいない。
                        しかしロールダウン効果は "イールド・カーブが不変" という強い仮定のもとで導入されるので、"所詮は教科書的な概念であり、実務においては参考程度" と認識する者もいる。
                        実際はイールド・カーブが変化したとき収益率への寄与の1つになるので、ロールダウン効果も確かに "存在" し、実務においても重要な議論の対象である。
                    </p>
                </div>
            </section>
        </main>
        <div id="nav-placeholder"></div>
        <script src="../../共通/load-nav.js" defer></script>
        <div id="footer-placeholder"></div>
        <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
        <script>
            $(function() {
                $('#footer-placeholder').load('../../共通/footer.html');
            });
        </script>
    </body>
</html>
