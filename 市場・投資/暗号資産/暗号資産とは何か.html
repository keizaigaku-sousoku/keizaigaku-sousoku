<!DOCTYPE html>
<html lang="ja">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>暗号資産とは何か</title>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
        <link rel="stylesheet" href="../../共通/stylesheet_contents.css">
        <link rel="stylesheet" href="../../共通/stylesheet_footer.css">
        <script src="../../共通/mathjax-config.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </head>
    <body>
        <header>
            <h2>暗号資産とは何か</h2>
        </header>
        <div class="subtitle">
            貨幣の民主化
        </div>
        <div class="toc-container">
            <div class="part">
                <h3 class="part-title">目次</h3>
                <a href="#section-p2p">電子署名・サーバー・P2P</a>
                <a href="#section-ledget">電子署名付き台帳</a>
                <a href="#section-distributed">分散台帳</a>
                <a href="#section-crypto">暗号資産</a>
                <a href="#section-pow">PoW</a>
                <a href="#section-ledget">ブロックチェーン</a>                
            </div>
        </div>
        <main>
            <section id="section-p2p">
                <h4>電子署名・サーバー・P2P</h4>
                <p>
                    　インターネットの利用者が爆発的に増加した現代において、"インターネット" という単語は極めて抽象的な概念に昇華されているものの、それが有する機能は大別すれば2つしかない。
                    1つ目は利用者が他の利用者に情報を送信する機能であり、2つ目は利用者が他の利用者から情報を送信された場合にそれを受信する機能である。
                    技術的な話題をさておけば、情報を送信したからといってそれが受信される保証はないが、受信するためには情報が送信されている必要がある。
                    したがってインターネットにおいては基本的に送信が受信に先行し、その後適切に受信が行われることで、はじめて情報の送受信が成り立つ。
                    <!--
                    一般に、利用者同士が一対一で対等に情報の送受信を行うことあるいはそのための技術を<span class="new-word">P2P（peer to peer）</span>と呼ぶ。
                    両者の送信と受信に一切の制限がなければ、それはP2Pである。
                    もし一方の送信または受信に制限があっても、他方に同様の制限があればそれもP2Pである。
                    しかし一方のみの送信または受信に制限があれば、それはP2Pでない。
                    -->
                </p>
                <p>
                    　インターネットによって情報を受信するとき、送信者を信頼できるか判定するための、古典的であるが現代でも通用する巧妙な暗号理論の手法がある。
                    バリエーションは無数にあるものの、概して以下の手順を<span class="new-word">公開鍵暗号方式（public-key encryption algorithms）</span>と呼ぶ。
                    まず任意のインターネット利用者 \(\textrm{X}\) は、ある時点で信頼できる判断した任意の利用者 \(\textrm{Y}\) に対して、一方に<span class="new-word">秘密鍵（secret key）</span>、もう一方に<span class="new-word">公開鍵（public key）</span>と名前をつけた \(\textrm{Y}\) 固有の相異なる文字列 \( \textrm{sk}_\textrm{Y} \)、\( \textrm{pk}_\textrm{Y} \) を送信しておく。
                    次に \(\textrm{X}\) は任意の文字列 \( m \) と任意の秘密鍵 \( \textrm{sk}_\textrm{Y} \) に対して文字列を返す2変数関数 \( \textrm{sign}(m,\textrm{sk}_\textrm{Y}) \) であって、引数から関数値を容易に求められるが、関数値から引数を推定することが困難なものを任意の利用者に公開しておく。
                    関数値 \( \textrm{sign}(m,\textrm{sk}_\textrm{Y}) \) を \( (m,\textrm{sk}_\textrm{Y}) \) の<span class="new-word">デジタル署名（digital signature）</span>と呼ぶ。
                    同時に \(\textrm{X}\) は任意の文字列 \( m \) 、任意の公開鍵 \( \textrm{pk}_\textrm{Y} \) 、任意の文字列 \( \sigma \) 対する3変数関数 \( \textrm{verify}(m,\textrm{pk}_\textrm{Y};\sigma) \) であって
                </p>    
                <div class="math-container">
                    \[
                        \textrm{verify}(m,\textrm{pk}_\textrm{Y};\sigma)=
                        \begin{cases}
                            1 &(\sigma=\textrm{sign}(m,\textrm{sk}_\textrm{Y}))\\
                            0 &(\sigma\neq\textrm{sign}(m,\textrm{sk}_\textrm{Y}))\\
                        \end{cases}
                    \]
                </div>
                <p>
                    を満たすものを任意の利用者に公開しておく。
                    そして \(\textrm{X}\) は任意の利用者 \(\textrm{Y}\) に対して、任意の文字列 \( m \) を送信するときは、自身の公開鍵 \( \textrm{pk}_\textrm{Y} \) とデジタル署名 \( \sigma=\textrm{sign}(m,\textrm{sk}_\textrm{Y}) \) を添えなければそれを受信しない旨を伝えておく。
                    以上の手順を準備しておけば、\(\textrm{X}\) は \( (m,\textrm{pk}_\textrm{Y};\sigma) \) を受信したとき、 \( \textrm{verify}(m,\textrm{pk}_\textrm{Y};\sigma) \) を計算し、結果が \( 1 \) になれば送信者が確かに \( \textrm{Y} \) であると信頼すればよい。
                </p>
                </p>
                <p>
                    　一部の者たちが蓄積した膨大な情報を他の者たちが利活用することは、現代におけるインターネットの典型的な使い方である。
                    一般に、一部の公的機関や企業（または稀に個人）であって標準的な個人よりも膨大な情報を蓄積する者あるいはそのための装置を<span class="new-word">サーバー（server）</span>と呼ぶ。
                    インターネットの利用者はサーバーに対して、任意の文字列 \( m \) を蓄積するよう " \( m \) を蓄積せよ" という文字列形式の情報を送信できる。
                    サーバーはそのような情報をつねに受信し、後述の方法で送信者を信頼できると判定すれば、 \( m \) を自動で蓄積するよう設計されている。
                    もし送信者を信頼できるか確認する手順がなければ、なりすましによって悪意のある情報がいくらでも蓄積されてしまう。
                    またインターネットの利用者はサーバーに対して、蓄積された情報 \( m^\prime \) を彼あるいは特定の者 \( \textrm{X} \) に宛てて送信するよう " \( \textrm{X} \) へ \( m^\prime \) を送信せよ"  という文字列形式の情報を送信できる。
                    サーバーはそのような信号をつねに受信し、後述の方法で送信者を信頼できると判定すれば、\( \textrm{X} \) へ \( m^\prime \) を自動で送信するよう設計されている。
                    もし送信者を信頼できるか確認する手順がなければ、なりすましによって悪意のある情報がXへ送信されてしまう。
                    もはや死語であろうが、いわゆる "ネットサーフィン" はサーバーから情報を受信する行為である。
                    またいずれ死語になるであろうが、いわゆる "SNS" はサーバーを介して利用者たちが情報を送受信する行為である。
                </p>
                <p>
                    　サーバーは文字列形式の情報を受信したとき、送信者を信頼できるか判定するために、古典的であるが現代でも通用する巧妙な暗号理論の手法を用いる。
                    バリエーションは無数にあるものの、以下の手順を<span class="new-word">公開鍵暗号方式（public-key encryption algorithms）</span>と呼ぶ。
                    まずサーバー \(\textrm{S}\) は任意の利用者 \(\textrm{X}\) に対して、一方に<span class="new-word">秘密鍵（secret key）</span>、もう一方に<span class="new-word">公開鍵（public key）</span>と名前をつけた \(\textrm{A}\) 固有の相異なる文字列 \( \textrm{sk}_\textrm{X} \)、\( \textrm{pk}_\textrm{X} \) を送信しておく。
                    <!--同時に \(\textrm{S}\) は任意の公開鍵を任意の利用者に公開する。-->
                    次に \(\textrm{S}\) は任意の文字列 \( m \) と任意の秘密鍵 \( \textrm{sk}_\textrm{X} \) に対して文字列を返す2変数関数 \( \textrm{sign}(m,\textrm{sk}_\textrm{X}) \) であって、引数から関数値を容易に求められるが、関数値から引数を推定することが困難なものを任意の利用者に公開しておく。
                    関数値 \( \textrm{sign}(m,\textrm{sk}_\textrm{X}) \) を \( (m,\textrm{sk}_\textrm{X}) \) の<span class="new-word">デジタル署名（digital signature）</span>と呼ぶ。
                    同時に \(\textrm{S}\) は任意の文字列 \( m \) 、任意の公開鍵 \( \textrm{pk}_\textrm{X} \) 、任意の文字列 \( \sigma \) 対する3変数関数 \( \textrm{verify}(m,\textrm{pk}_\textrm{X};\sigma) \) であって
                </p>    
                <div class="math-container">
                    \[
                        \textrm{verify}(m,\textrm{pk}_\textrm{X};\sigma)=
                        \begin{cases}
                            1 &(\sigma=\textrm{sign}(m,\textrm{sk}_\textrm{X}))\\
                            0 &(\sigma\neq\textrm{sign}(m,\textrm{sk}_\textrm{X}))\\
                        \end{cases}
                    \]
                </div>
                <p>
                    を満たすものを任意の利用者に公開しておく。
                    そして \(\textrm{S}\) は任意の利用者 \(\textrm{X}\) に対して、任意の文字列 \( m \) を送信するときは、自身の公開鍵 \( \textrm{pk}_\textrm{X} \) とデジタル署名 \( \sigma=\textrm{sign}(m,\textrm{sk}_\textrm{X}) \) を添えなければそれを受信しない旨を伝えておく。
                    以上の手順を準備しておけば、\(\textrm{S}\) は都度 \( \textrm{verify}(m,\textrm{pk}_\textrm{X};\sigma) \) を計算し、結果が \( 1 \) になれば送信者を信頼すればよい。
                </p>
                <p>
                    　公開鍵暗号方式について、基本的な事項で何点か補足が必要である。
                    1点目として、公開鍵暗号方式はサーバーとその利用者の情報の送受信に限らず、他の様々な場面でも応用される汎用性の高い技術である。
                    実際、上記のサーバー \(\textrm{S}\) と任意のサーバー利用者 \(\textrm{X}\) を任意のインターネット利用者たちに置換することで、議論は容易に一般化される。
                    標語的に言えば "公開鍵暗号方式とは、文字列にデジタル署名を添えて送信することで、送信者への信頼を担保する技術" である。
                    なお送信者は文字列の内容を任意に決められるため、言うまでもなくその内容の信憑性は一切担保されない。
                    2点目として、利用者は秘密鍵と公開鍵を他者に公開することが禁止されていない。
                    またそもそも、サーバーが利用者たちの秘密鍵と公開鍵の適切な管理をつねに把握することは、現実的に困難である。
                    利用者が自身の秘密鍵を公開した場合彼のみがなりすましの被害を受けるという仕組みになっているので、合理的な利用者は少なくとも秘密鍵を公開しない。
                    なお利用者は秘密鍵を手元に保管しておりこれをサーバーに送信することはない。
                    もし悪意ある者が \( (m,\textrm{pk}_\textrm{X};\sigma) \) を不正に傍受した場合、彼にとって有益な情報は \( m \) のみであり、\(\textrm{X}\) になりすまそうとしても方程式 \( \sigma=\textrm{sign}(m,\textrm{sk}_\textrm{X}) \) を \( \textrm{sk}_\textrm{X} \) について解く必要があり困難である。
                </p>
                    
                <p>
                    つまり \( \textrm{verify} \) は任意の文字列 \( m \) と秘密鍵 \( \textrm{sk}_\textrm{X} \) およびそのデジタル署名 \( \textrm{sign}(m,\textrm{sk}_\textrm{X}) \) に対して、\( \sigma:=\textrm{sign}(m,\textrm{sk}) \in \{0,1\}^N \) 、\( N \in \textbf{Z}_{\geq1}\) としておくと便利である。
                    なお \( N \) が大きいほどデジタル署名を当てずっぽうで当てられる確率は下がるが、情報量が大きくなって不便になるため、状況に応じて適宜最適化する必要がある。
                    
                    また
                    さらに任意の利用者Aが固有の文字列 \( \textrm{sk} \) を受信していて、Sへ文字列 \( m \) を送信するときは、\( \sigma:=\textrm{sign}(m,\textrm{sk}) \) を添えるよう指示しておく。
                    関数値 \( \sigma \) を<span class="new-word">デジタル署名（digital signature）</span>と呼ぶ。
                    
                    
                    
                    ここで \( \textrm{sign} \) に単射であることを課す必要はなく、実用面では定義域の大きさによらず値域を \( \{0,1\}^N \) 、\( N \in \textbf{Z}_{\geq1}\) としておくと便利である。
                    なお \( N \) が大きいほどデジタル署名を当てずっぽうで当てられる確率は下がるが、情報量が大きくなって不便になるため、状況に応じて適宜最適化する必要がある。
                </p>
                <p>

                    
                    バリエーションは無数にあるものの、"信憑性を担保" するための以下の手順を<span class="new-word">公開鍵暗号方式（public-key encryption algorithms）</span>と呼ぶ。
                    まずサーバーSはある文字列をインターネット上に公開しておき、サーバーの利用者Aにのみ別のある文字列を送信しておく。
                    便宜的に前者を \( \textrm{pk} \) 、後者を \( \textrm{sk} \) とおく。
                    
                </p>
                <p>
                    　インターネットが情報を送受信するための便利な技術に留まらず、情報化社会という新たな世相を構築していくにあたり、サーバーによる情報の局在化と送受信の中央集権化は相補的な指導原理であった。
                    2000年代頃以降にスマートフォンが世界中で爆発的に普及したことで、安全で安定した情報の蓄積と送受信を可能にするサーバーの重要性は飛躍的に上昇した。
                    歴史を振り返れば、そこに商機を見出したのは主に米国の新興企業たちであった。
                    彼らが開発したサーバー群は単に情報を蓄積して要求された情報を送信するだけでなく、膨大な情報から効率的に指定の情報を発見する仕掛けを実装したり、インターネット上に広告を掲載する新たなマーケティングの舞台を整えたりした。
                    インターネット利用者がその圧倒的な利便性を備えたサーバー群を利用するにつれて、情報の局在化と送受信の中央集権化は加速的に進んでいった。                    
                </p>
            </section>
            <section id="section-ledget">
                <h4>電子署名付き台帳</h4>
                <p>
                    　情報とその交換に限った話ではないが、中央集権化には利点と欠点が存在する。
                    もっとも重要な利点の1つは、中央が全体を管理できることである。
                    そして同時にもっとも重大な欠点の1つは、中央が全体を管理できなくなる可能性があることである。
                    政治的な話題を避けるのであれば、実際に中央集権化の欠点が顕現した事例としてリーマン・ショック（世界金融危機）が有名である。
                    世界中の貨幣の取引を米国に集中させていた状況で、一部の取引に経済的な理由で不履行が発生し、その影響が世界中に伝播した。
                    このリーマン・ショックの渦中において、P2Pを用いた革命的な貨幣の取引が考案された。
                </p>
                <p>
                    　貨幣の取引において、その結果を貨幣の受渡でなく記録によって管理することは、はるか昔から日常的に行われてきた。
                    一般にその記録を<span class="new-word">台帳（ledget）</span>、その更新を<span class="new-word">記帳（record）</span>と呼ぶ。
                    簡単のため1種類の貨幣のみを考えるならば、記帳すべき情報はいつ・誰が・誰へ・いくら渡すのかが少なくとも必要である。
                    （受渡で受けと渡しは不可分であるから、上記はいくら受取るのかでも議論は同様である。）
                    例えば商人がノートに1行ずつ貨幣の取引を記帳していけば、都度貨幣を受渡すことなく商売を行える。
                    適当なタイミングで台帳を見直し、受けと渡しを必要に応じて相殺して差額のみを実際に受渡すことで、最小限の手間で必要なだけの貨幣を取引できる。
                </p>
                <p>
                    　インターネットの登場により、個人あるいはサーバーが台帳を管理するという発想が生まれた。
                    もしサーバーが管理するのであれば、個人は貨幣の取引が発生するたびに情報を送信し、台帳を更新つまり記帳すればよい。
                    しかしこれだけの仕組みでは、悪意を持った個人が架空の記帳を無制限に行えてしまい、台帳は機能しない。
                    
                </p>
            </section>

            <section id="section-portfolio">
                <h4>ポートフォリオの定義</h4>
                <p>
                    あ
                </p>
                <div class="comment-box">
                    <p>
                        <span class="comment-box-title">ロールダウン効果の実在性</span>
                    </p>
                    <p>
                        債券といえば、クーポンやデュレーションが議論の対象になることが多い。
                        クーポンは債券に明記され、デュレーションは定義式から計算されるため、これらの "存在" を疑う者はいない。
                        しかしロールダウン効果は "イールド・カーブが不変" という強い仮定のもとで導入されるので、"所詮は教科書的な概念であり、実務においては参考程度" と認識する者もいる。
                        実際はイールド・カーブが変化したとき収益率への寄与の1つになるので、ロールダウン効果も確かに "存在" し、実務においても重要な議論の対象である。
                    </p>
                </div>
            </section>
        </main>
        <div id="nav-placeholder"></div>
        <script src="../../共通/load-nav.js" defer></script>
        <div id="footer-placeholder"></div>
        <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
        <script>
            $(function() {
                $('#footer-placeholder').load('../../共通/footer.html');
            });
        </script>
    </body>
</html>
