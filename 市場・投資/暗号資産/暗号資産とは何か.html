<!DOCTYPE html>
<html lang="ja">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>暗号資産とは何か</title>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
        <link rel="stylesheet" href="../../共通/stylesheet_contents.css">
        <link rel="stylesheet" href="../../共通/stylesheet_footer.css">
        <script src="../../共通/mathjax-config.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </head>
    <body>
        <header>
            <h2>暗号資産とは何か</h2>
        </header>
        <div class="subtitle">
            貨幣の民主化
        </div>
        <div class="toc-container">
            <div class="part">
                <h3 class="part-title">目次</h3>
                <a href="#section-public">公開鍵暗号方式</a>
                <a href="#section-server-p2p">サーバー・P2P</a>
                <a href="#section-ledget">電子署名付き台帳</a>
                <a href="#section-distributed">分散台帳</a>
                <a href="#section-crypto">暗号資産</a>
                <a href="#section-pow">PoW</a>
                <a href="#section-ledget">ブロックチェーン</a>                
            </div>
        </div>
        <main>
            <section id="section-public">
                <h4>公開鍵暗号方式</h4>
                <p>
                    　インターネットの利用者が爆発的に増加した現代において、"インターネット" という単語は極めて抽象的な概念に昇華されているものの、それが有する機能は大別すれば2つしかない。
                    1つ目は利用者が他の利用者に情報を送信する機能であり、2つ目は利用者が他の利用者から情報を送信された場合にそれを受信する機能である。
                    技術的な話題をさておけば、情報を送信したからといってそれが受信される保証はないが、受信するためには情報が送信されている必要がある。
                    したがってインターネットにおいては基本的に送信が受信に先行し、その後適切に受信が行われることで、はじめて情報の送受信が成り立つ。
                </p>
                <p>
                    　インターネットによって情報を受信するとき、送信者を信頼できるか判定するための、古典的であるが現代でも通用する巧妙な暗号理論の手法がある。
                    バリエーションは無数にあるものの、概して以下の手順を<span class="new-word">公開鍵暗号方式（public-key encryption algorithms）</span>と呼ぶ。
                    まず任意のインターネット利用者 \(\textrm{X}\) は、ある時点で信頼できると判断した任意の利用者 \(\textrm{Y}\) に対して、一方に<span class="new-word">秘密鍵（secret key）</span>、もう一方に<span class="new-word">公開鍵（public key）</span>と名前をつけた \(\textrm{Y}\) 固有の相異なる文字列 \( \textrm{sk}_\textrm{Y} \)、\( \textrm{pk}_\textrm{Y} \) を送信しておく。
                    次に \(\textrm{X}\) は任意の文字列 \( m \) と任意の秘密鍵 \( \textrm{sk}_\textrm{Y} \) に対して文字列を返す2変数関数 \( \textrm{sign}(m,\textrm{sk}_\textrm{Y}) \) であって、引数から関数値を容易に求められるが、関数値から引数を推定することが困難なものを任意の利用者に公開しておく。
                    関数値 \( \textrm{sign}(m,\textrm{sk}_\textrm{Y}) \) を \( (m,\textrm{sk}_\textrm{Y}) \) の<span class="new-word">デジタル署名（digital signature）</span>と呼ぶ。
                    同時に \(\textrm{X}\) は任意の文字列 \( m \) 、任意の公開鍵 \( \textrm{pk}_\textrm{Y} \) 、任意の文字列 \( \sigma \) 対する3変数関数 \( \textrm{verify}(m,\textrm{pk}_\textrm{Y};\sigma) \) であって
                </p>    
                <div class="math-container">
                    \[
                        \textrm{verify}(m,\textrm{pk}_\textrm{Y};\sigma)=
                        \begin{cases}
                            1 &(\sigma=\textrm{sign}(m,\textrm{sk}_\textrm{Y}))\\
                            0 &(\sigma\neq\textrm{sign}(m,\textrm{sk}_\textrm{Y}))\\
                        \end{cases}
                    \]
                </div>
                <p>
                    を満たすものを用意しておく。
                    そして \(\textrm{X}\) は任意の利用者 \(\textrm{Y}\) に対して、任意の文字列 \( m \) を送信するときは、自身の公開鍵 \( \textrm{pk}_\textrm{Y} \) とデジタル署名 \( \sigma=\textrm{sign}(m,\textrm{sk}_\textrm{Y}) \) を添えなければそれを信頼しない旨を伝えておく。
                    以上の手順を準備しておけば、\(\textrm{X}\) は \(\textrm{Y}\) から受信したと断定できない情報 \( (m,\textrm{pk}_\textrm{Y};\sigma) \) に対して \( \textrm{verify}(m,\textrm{pk}_\textrm{Y};\sigma) \) を計算し、結果が \( 1 \) になれば送信者を確かに \( \textrm{Y} \) であると信頼すればよい。
                </p>
                <p>
                    　公開鍵暗号方式について、基本的な事項で何点か補足が必要である。
                    1点目として、公開鍵暗号方式は情報の送信者を特定の者と信頼できるか判定する手法であり、情報の信憑性は一切保証しない。
                    送信者を特定の者と信頼できても、彼が悪意を持っているかは分からず、情報そのものはいくらでも不確かで危険なものになり得る。
                    2点目として、利用者は秘密鍵と公開鍵を他者に公開することが禁止されていない。
                    したがって公開することは自由であるが、その場合彼はなりすましの被害を受ける可能性があるため、合理的な者は誰も公開しないだけである。
                    3点目として、\( \textrm{sign} \) と \( \textrm{verify} \) は実際に機能する関数が数多く知られており、現実世界で幅広く用いられている（RSA、ECDSA、Schnorr署名等）。
                    言うまでもなく、\( \textrm{sign} \) と \( \textrm{verify} \) の順問題は容易であるほど \( \textrm{sign} \) の逆問題は難解であるほど実用性が高い。
                </p>
            </section>
            <section id="section-server-p2p">
                <h4>サーバー・P2P</h4>
                <p>
                    　一部の者たちが蓄積した膨大な情報を他の者たちが利活用することは、現代におけるインターネットの典型的な使い方である。
                    一般に、一部の公的機関や企業（または稀に個人）であって標準的な個人よりも膨大な情報を蓄積する者あるいはそのための装置を<span class="new-word">サーバー（server）</span>と呼ぶ。
                    インターネットの利用者はサーバーに対して、任意の文字列 \( m \) を蓄積するよう " \( m \) を蓄積せよ" という文字列形式の情報を送信できる。
                    サーバーはそのような情報をつねに受信し、公開鍵暗号方式で送信者を信頼できると判定すれば、 \( m \) を自動で蓄積するよう設計されている。
                    もし送信者を信頼できるか確認する手順がなければ、なりすましによって悪意のある情報がいくらでも蓄積されてしまう。
                    またインターネットの利用者はサーバーに対して、蓄積された情報 \( m^\prime \) を彼あるいは特定の者 \( \textrm{X} \) に宛てて送信するよう " \( \textrm{X} \) へ \( m^\prime \) を送信せよ"  という文字列形式の情報を送信できる。
                    サーバーはそのような信号をつねに受信し、公開鍵暗号方式で送信者を信頼できると判定すれば、\( \textrm{X} \) へ \( m^\prime \) を自動で送信するよう設計されている。
                    もし送信者を信頼できるか確認する手順がなければ、なりすましによって悪意のある情報が \( \textrm{X} \) へ送信されてしまう。
                    もはや死語であろうが、いわゆる "ネットサーフィン" はサーバーから情報を受信する行為である。
                    またいずれ死語になるであろうが、いわゆる "SNS" はサーバーを介して利用者たちが情報を送受信する行為である。
                </p>
                <p>
                    　インターネットが情報を送受信するための便利な技術に留まらず、情報化社会という新たな世相を構築していくにあたり、サーバーによる情報の局在化と送受信の中央集権化は相補的な指導原理であり続けた。
                    2000年代頃以降にスマートフォンが世界中で爆発的に普及したことで、安全で安定した情報の蓄積と送受信を可能にするサーバーの重要性は飛躍的に上昇した。
                    歴史を振り返れば、そこに商機を見出したのは主に米国の新興企業たちである。
                    彼らは単に情報を蓄積して要求された情報を送信するサーバー群を開発するだけでなく、膨大な情報から効率的に指定の情報を発見する仕掛けを実装したり、インターネット上に広告を掲載する新たなマーケティングの舞台を整えたりした。
                    インターネット利用者がその圧倒的に便利なサーバー群を利用するにつれて、情報の局在化と送受信の中央集権化は加速的に進んでいった。                    
                </p>
                <p>
                    　情報とその送受信に限った話ではないが、中央集権化には利点と欠点が存在する。
                    もっとも重要な利点の1つは、中央が全体を管理できることである。
                    そして同時にもっとも重大な欠点の1つは、中央が全体を管理できなくなる可能性があることである。
                    またもし中央が高度な管理を実現し一時的に万事を上手く回しても、その管理がどれだけ完全に近く持続的であるかという問題に対して中央は解を持ち得ない。
                </p>
                <p>
                    　中央集権化が過度に進んだ場合、そのアンチテーゼとして権力や管理の分散が提唱されることは世の常である。
                    インターネットでも何らかの中央集権化が進むたび、分散を図るような方法が自然発生的に提唱されてきた。
                    その土台すなわちインターネットの利用者たちが互いに対等な条件で情報を送受信するための技術を<span class="new-word">P2P（peer-to-peer）</span>と呼ぶ。
                    利用者の一方に送受信に係る条件が課されているとき、もう一方にも同様の条件が課されていればそれはP2Pである。
                    サーバーとその利用者の間の送受信は明らかに非対称でありP2Pではない。
                    P2Pは1970年代頃に確立された古典的な技術であるが、公開鍵暗号方式と同様に汎用性が高く多様な場面で応用される。
                    重要なことは、どのような中央集権化に対してP2Pと公開鍵暗号方式でどのように権力や管理の分散を図るかである。
                </p>
            </section>
            <section id="section-ledget">
                <h4>電子署名付き台帳</h4>
                <p>
                    　貨幣の取引において、その結果を貨幣の受渡でなく記録によって管理することは、はるか昔から日常的に行われてきた。
                    記録を<span class="new-word">台帳（ledget）</span>、その更新を<span class="new-word">記帳（record）</span>と呼ぶ。
                    簡単のため1種類の貨幣のみを考えるならば、記帳すべき情報は少なくとも "いつ・誰が・誰へ・いくら渡す" が必要である。
                    （受渡で受けと渡しは不可分であるから、上記はいくら受取るのかでも議論は同様である。）
                    例えば商人がノートに1行ずつ貨幣の取引を記帳していけば、都度貨幣を受渡すことなく商売を行える。
                    適当なタイミングで台帳を見直し、受けと渡しを必要に応じて相殺して差額のみを実際に受渡すことで、最小限の手間で必要なだけの貨幣を取引できる。
                </p>
                <p>
                    　インターネットの登場により、サーバーが台帳を管理するという発想が生まれた。
                    任意の利用者 \( \textrm{X} \) は任意の利用者 \( \textrm{X} \) へ貨幣の支払いが発生するたびサーバーへ "いつ・\( \textrm{X} \) が・\( \textrm{Y} \) へ・いくら渡す" という文字列形式の情報をデジタル署名とともに送信すればよい。
                    サーバーは公開鍵暗号方式で送信者を信頼できると判定すれば台帳を更新し、それをもって \( \textrm{X} \) の記帳が完了する。
                    貨幣を支払う者が記帳するよう定めておけば、望んで貨幣を失う非合理な者がいない限り台帳は信頼できるものになる。
                    ただしサーバーは一切の悪意を持たず台帳を改竄しないはずであり、サーバーは十分高度であって台帳は悪意ある者から改竄を受けないはずであるという条件は暗に仮定されている。
                </p>
                <p>
                    　インターネットで台帳を管理するならば、改竄が起こり得るサーバーに頼りきらず、任意の利用者がP2Pと公開鍵暗号方式で台帳を管理する方法も1つの選択になり得る。
                    便宜上、さしあたり任意の利用者 \( \textrm{A} \) が台帳を管理することにする。
                    上記と同様に、任意の利用者 \( \textrm{X} \) は任意の利用者 \( \textrm{X} \) へ貨幣の支払いが発生するたび \( \textrm{A} \) へ "いつ・\( \textrm{X} \) が・\( \textrm{Y} \) へ・いくら渡す" という文字列形式の情報をデジタル署名 \( \sigma=\textrm{sign}(m,\textrm{sk}_\textrm{X}) \) とともに送信する。
                    やはり \( \textrm{A} \) は公開鍵暗号方式で送信者を信頼できると判定すれば台帳を更新し、それをもって \( \textrm{X} \) の記帳が完了する。
                    ここで \( \textrm{A} \) のみが台帳のすべてを閲覧できれば記帳はP2Pではなくなるので、台帳は利用者全員に公開される必要がある。
                    また記帳の信憑性を担保するために各 \( m \) にデジタル署名 \( \sigma \) を添えておく必要がある。
                    このとき、悪意ある者が任意の記帳を再実行して台帳を改竄する可能性が生じる。
                    例えば \( \textrm{Y} \) に悪意がある場合、公開されている \( m \) に同じく公開されている \( \sigma \) を添えて \( \textrm{A} \) へ送信すれば、それは貨幣を支払う \( \textrm{X} \) の記帳ではないにも関わらず台帳に記帳されてしまう。
                    これを回避するためには、\( \textrm{X} \) が記帳するとき \( m \) の文頭に固有の整数 \( k \in \textbf{Z}_{\geq1} \) を添えて \( m_k \) とすればよい。
                    例えば台帳において \( k \) 番目（行目）の記帳であるとき \( k \) を添えれば十分である。
                    すると公開されるのは \( m_k \) と \( \sigma_k=\textrm{sign}(m_k,\textrm{sk}_\textrm{X}) \) であり、もし悪意ある者が \( m_l \) 、\( l\neq k \) を記帳しようとしても、彼は \( \textrm{sk}_\textrm{X} \) を知らず \( \sigma_l=\textrm{sign}(m_l,\textrm{sk}_\textrm{X}) \) を生成できないので台帳を改善できない。

                    <!--
                    しかしこれだけの仕組みではコピー・アンド・ペーストで記帳が容易に複製されて支払いの重複が起こり得る。
                    例えば
                    例えば \( \textrm{X} \) でも \( \textrm{Y} \) でもない利用者 \( \textrm{Z} \) が悪意を持っていて
                    そこでサーバーは以下の方法によって架空の記帳と記帳の重複を回避すればよい。
                    まずサーバーは \( m \) に固有の添字 \( k \in \textbf{Z}_{\geq1} \) を振って \( m_k \) とする。
                    次にサーバーは \( m_k \) を暫定版として一度記帳し、"誰が" に相当する利用者 \( \textrm{Y} \) に \( m_k \) を送信してそれに対するデジタル署名を要求する。
                    もし \( \textrm{Y} \) が \( m_k \) の内容に納得すればデジタル署名 \( \sigma=\textrm{sign}(m_k,\textrm{sk}_\textrm{Y}) \) が生成されるので、サーバーは \( (m_k,\sigma) \) を得る。
                    最後にサーバーは \( \textrm{verify}(m,\textrm{pk}_\textrm{Y};\sigma) \) を計算し、結果が \( 1 \) になれば \( (m_k,\sigma) \) を正式版として記帳し、\( 0 \) になれば暫定版を棄却する。
                    以上を実行すれば、\( \textrm{X} \) は架空の記帳を試みても \( \textrm{Y} \) が合理的であればデジタル署名をサーバーに送信しないので記帳は成り立たない。
                    （もし \( \textrm{Y} \) が合理的でなければデジタル署名をサーバーに送信して記帳が成り立つが、単に \( \textrm{Y} \) が貨幣を失うだけである。）
                    -->
                </p>
            </section>

            <section id="section-portfolio">
                <h4>ポートフォリオの定義</h4>
                <p>
                    あ
                </p>
                <div class="comment-box">
                    <p>
                        <span class="comment-box-title">ロールダウン効果の実在性</span>
                    </p>
                    <p>
                        債券といえば、クーポンやデュレーションが議論の対象になることが多い。
                        クーポンは債券に明記され、デュレーションは定義式から計算されるため、これらの "存在" を疑う者はいない。
                        しかしロールダウン効果は "イールド・カーブが不変" という強い仮定のもとで導入されるので、"所詮は教科書的な概念であり、実務においては参考程度" と認識する者もいる。
                        実際はイールド・カーブが変化したとき収益率への寄与の1つになるので、ロールダウン効果も確かに "存在" し、実務においても重要な議論の対象である。
                    </p>
                </div>
            </section>
        </main>
        <div id="nav-placeholder"></div>
        <script src="../../共通/load-nav.js" defer></script>
        <div id="footer-placeholder"></div>
        <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
        <script>
            $(function() {
                $('#footer-placeholder').load('../../共通/footer.html');
            });
        </script>
    </body>
</html>
